[ { "title": "How to make a real fast replay mode", "url": "/blog/posts/a-real-fast-replay-mode/", "categories": "Tips", "tags": "replay, front", "date": "2021-11-18 16:33:00 +0100", "snippet": "This is the story of how I went from this (~1min for 80 replayed moves) :to this (~8sec) :Before diving into code, maybe you are asking yourself:Well, when you have a bug report at move 450 that needs more than 8min to reach, you start wondering why is fast mode not that fast :)Fast replay modeSome players don’t know that feature, but once you enter a replay, you have access to a fast replay mode under the “advanced settings” link:(let’s not get distracted by the fact that the link is translated while the menu is not…)But what is this fast mode doing exactly? Diving into BGA framework’s code, we can find this:setModeInstataneous: function () { if (this.instantaneousMode == false) { this.instantaneousMode = true; this.savedSynchronousNotif = dojo.clone(this.notifqueue.synchronous_notifs); dojo.style(&#39;leftright_page_wrapper&#39;, &#39;visibility&#39;, &#39;hidden&#39;); dojo.style(&#39;loader_mask&#39;, &#39;display&#39;, &#39;block&#39;); dojo.style(&#39;loader_mask&#39;, &#39;opacity&#39;, 1); for (var i in this.notifqueue.synchronous_notifs) { if (this.notifqueue.synchronous_notifs[i] != - 1) { this.notifqueue.synchronous_notifs[i] = 1; } } }},Clicking on this button has the following consequences: setting instantaneousMode = true, which is used in slideTo to reduce the duration to 1, and in various other framework transition function (fadeOut, addToStock, …) displaying the “loader_mask” element on top of everything else reducing synchronous duration of notifications to 1This sounds like a great idea, so why is it still so slow? Let’s use the performance tool to see what is happening:(you can click on a row to have more details about which part of the code is corresponding to that row)Here are the three main bottlenecks that might arises in any games: some notifications seems to take as much time as in normal slow mode there are bunch of setTimeout floating around there are a lot of style recalculationFor experimenting while trying to solve these issues, it was convenient to have an helper function that I could switch on/off easily:isFastMode(){ return this.instantaneousMode; // true / false}That way, returning true would allow to use the normal step-by-step replay while mimicking the fast mode.Improving notificationsThe framework is making all notifications synch timing to 1sec, which sounds good but has two flaws: if you are using non-framework animations, this can break you code as notifications will run one after the other without checking that the animation is over if you are using dynamic synch timing (using this.notifqueue.setSynchronousDuration), then your notification will take the same time as in a normal slow replaySo the first step was to make all the notifications fast-replay-compatible. For instance, we have this notification in Agricola when a player play a card that will zoom on the card, them zoom off to its location before resolving the notification, which is useless in fast mode. So I just add a bypass of the whole flow by checking the value of isFastMode: notif_buyCard(n) { debug(&#39;Notif: buying a card&#39;, n); let card = n.args.card; let duration = 700; let waitingTime = 80000 / this._cardAnimationSpeed; // Create the card if needed, and compute initial location of sliding event let exists = $(card.id); let from = this.computeSlidingAnimationFrom(card, &#39;cards-wrapper-&#39; + card.pId); if (this.isFastMode()) { this.notifqueue.setSynchronousDuration(0); } else { // Zoom on it, then zoom off this.zoomOnCard(card.id, { from, duration }) .then(() =&amp;gt; this.wait(waitingTime)) .then(() =&amp;gt; this.zoomOffCard({ duration })) .then(() =&amp;gt; this.notifqueue.setSynchronousDuration(10)); } ...}I don’t like that much the fact that notification timing are hardcoded to 1 in this mode, so I made it more flexible by allowing the notifications to enforce their synch time if they need to:this._notifications = [ [&#39;revealActionCard&#39;, 1100], [&#39;placeFarmer&#39;, null], [&#39;growChildren&#39;, 1000], ...];setupNotifications() { console.log(this._notifications); this._notifications.forEach((notif) =&amp;gt; { var functionName = &#39;notif_&#39; + notif[0]; let wrapper = (args) =&amp;gt; { let timing = this[functionName](args); if (timing === undefined) { if (notif[1] === undefined) { console.error( &quot;A notification don&#39;t have default timing and didn&#39;t send a timing as return value : &quot; + notif[0], ); return; } // Override default timing by 0 in case of fast replay mode timing = this.isFastMode() ? 0 : notif[1]; } if (timing !== null) { this.notifqueue.setSynchronousDuration(timing); } }; });}Making the flow as asynch as possibleNow let’s take care of these bunch of setTimeouts, which are coming from two main part in my case: sliding animations which have in a setTimeout with duration 1 for the onEnd listener -_-‘ counters????Improve slide functionAll my slidings are usually the attach: true parameter of my slide functions which means: once the animation is over, attach the mobile element to the target and remove absolute positionning. What a waste of resources to do all that in fast-mode where it’s basically the same as just moving directly the node around:slide(mobileElt, targetElt, options = {}) { ... // Mobile elt mobileElt = $(mobileElt); let mobile = mobileElt; // Target elt targetElt = $(targetElt); let targetId = targetElt; let newParent = config.attach ? targetId : $(mobile).parentNode; // Handle fast mode if (this.isFastMode() &amp;amp;&amp;amp; (config.destroy || config.clearPos)) { if (config.destroy) dojo.destroy(mobile); else dojo.place(mobile, targetElt); return new Promise((resolve, reject) =&amp;gt; { resolve(); }); } ...}CountersIn Agricola, we are using a loooot of counters for scores, resources, …Inside notifications, we are using the toValue to have this nice animation while playing the game. But these animations are useless in fast mode!But shouldn’t the framework be handling this as for reducing the duration of slideTo function? Well it probably should, but it’s not doing it….So let’s make our own by copying the existing one (and improve it to handle floating value as well).Instead of creating a dojo component, I just went a dirty way by creating an object on the fly with corresponding methods, please don’t puke while reading this:/** * Own counter implementation that works with fast mode replay */createCounter(id, defaultValue = 0) { if (!$(id)) { console.error(&#39;Counter : element does not exist&#39;, id); return null; } let game = this; let o = { span: $(id), targetValue: 0, currentValue: 0, speed: 100, getValue: function () { return this.targetValue; }, setValue: function (n) { this.currentValue = +n; this.targetValue = +n; this.span.innerHTML = +n; }, toValue: function (n) { if (game.isFastMode()) { this.setValue(n); return; } this.targetValue = +n; if (this.currentValue != n) { this.span.classList.add(&#39;counter_in_progress&#39;); setTimeout(() =&amp;gt; this.makeCounterProgress(), this.speed); } }, incValue: function (n) { let m = +n; this.toValue(this.targetValue + m); }, makeCounterProgress: function () { if (this.currentValue == this.targetValue) { setTimeout(() =&amp;gt; this.span.classList.remove(&#39;counter_in_progress&#39;), this.speed); return; } let step = Math.ceil(Math.abs(this.targetValue - this.currentValue) / 5); this.currentValue += (this.currentValue &amp;lt; this.targetValue ? 1 : -1) * step; this.span.innerHTML = this.currentValue; setTimeout(() =&amp;gt; this.makeCounterProgress(), this.speed); }, }; o.setValue(defaultValue); return o;},This is the new speed after doing all these changes, pretty neat already:Prevent the repaintsWhen looking to the perf tool, the main bottleneck seems to be style calculation, which is normal because we are moving a lot of stuff around. Wait, I’m not actually seeing everything moving around since it’s hidden beside the loading mask, so the browser should do that silently, right ?The answer is: that’s depend what hidden means. If we look back at setModeInstataneous, we can see that the function is doing this change of style of the main container:dojo.style(&#39;leftright_page_wrapper&#39;, &#39;visibility&#39;, &#39;hidden&#39;);Hidding an element with this css property will keep it’s width/height so that means the browser has to recompute the styles to properly updates the width/height of this element, even if you can’t see it!The solution is pretty easy then, just use display:none instead! Actually, we will need a bit more work because the loading screen won’t have the proper height now that the main container is not longer displayed, which can be easily fixed by doing a cleaner loading screen solution:constructor() { ... dojo.place(&#39;loader_mask&#39;, &#39;overall-content&#39;, &#39;before&#39;); dojo.style(&#39;loader_mask&#39;, { height: &#39;100vh&#39;, position: &#39;fixed&#39;, });},// Overwrite this to make display:nonesetModeInstataneous() { if (this.instantaneousMode == false) { this.instantaneousMode = true; dojo.style(&#39;leftright_page_wrapper&#39;, &#39;display&#39;, &#39;none&#39;); dojo.style(&#39;loader_mask&#39;, &#39;display&#39;, &#39;block&#39;); dojo.style(&#39;loader_mask&#39;, &#39;opacity&#39;, 1); }},// Overwrite this to make display:block after fast mode is offunsetModeInstantaneous() { if (this.instantaneousMode) { this.instantaneousMode = false; dojo.style(&#39;leftright_page_wrapper&#39;, &#39;display&#39;, &#39;block&#39;); dojo.style(&#39;loader_mask&#39;, &#39;display&#39;, &#39;none&#39;); }},And now we finally get this much nicer speed:" } ]
